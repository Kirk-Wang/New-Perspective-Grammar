Now. You've heard me talk about these container runtimes,

and maybe Docker, or maybe one of

the other options. You might want to ask, do we need Docker

at all? Right. Why are we talking about Docker if it's

optional?

现在。你听我说过这些容器运行时，
也许还有Docker，
或者其他的选项。
你可能想问，我们需要Docker吗？
正确的。
如果Docker是可选的，
我们为什么要谈论它？
* at all全然; 一点; 全然，根本，究竟

Well, like I said, Kubernetes definitely needs a container

runtime, but it doesn't have to be Docker.

好吧，就像我说的，
Kubernetes 确实需要一个容器运行时，
但它不一定是 Docker。

For the longest time now, Kubernetes has

been using Docker largely by default.

很长一段时间以来，Kubernetes一直默认使用Docker。
* longest adv.长期地;长久地;(在某一时间或事件之前或以后)很久地;用于名词后强调某事发生在某整段时间
* largely adv.在很大程度上;多半;主要地

Different distributions will use it by default.

不同的发行版将默认使用它。

Obviously, Docker's tooling uses Docker Engine by default.

显然，Docker工具默认使用Docker引擎。
* Obviously adv.(用于陈述认为别人已知道或希望别人同意的事)显然，明显地;(用于说明某种情况或事实)显而易见，明显，不言而喻

That was because Docker was first, and it

is generally the easiest and most well supported.

那是因为 Docker 是第一个，而且它通常是最简单和最受支持的。
* generally adv.普遍地;广泛地;一般地;通常;大体上;笼统地;概括地;大概

It's got the longest production history of every one of

them, so it tends to be the most stable.

它拥有最长的生产历史，所以它往往是最稳定的。
* be the most 是最好的
* tend v.往往会;常常就;趋向;走向;倾向;趋于;照料;照管;护理

But, we can choose others.

但是，我们可以选择其他的。

If you've been around a while, you might have heard

something called Rocket.

如果你已经围绕着这些有一段时间了，你可能听说过一种叫 Rocket 的东西。

Unfortunately, Rocket is no longer supported.

不幸的是，Rocket 已经不受支持了。
* no longer 不再

CoreOS was bought by RedHat, and

they're working on a different project.

CoreOS 被 RedHat 收购了，他们正在进行一个不同的项目。
* working on 致力于；作用于；继续工作

So, they didn't really need two.

所以，他们并不需要两个。

So, they kind of got rid of Rocket.

所以，他们摆脱了火箭。
* kind of 稍微; 有几分; 有点儿
* got rid of 除去;摆脱;扔掉;去掉

It's still around, but it's no longer supported in

the latest versions of Kubernetes. One other option,

instead of using Docker, is to use containerd, which

is technically still largely maintained by Docker. It's actually

它仍然存在，
但是在 Kubernetes 的最新版本中不再支持它。
另一种选择是使用 containerd，
而不是使用Docker，
它在技术上仍然主要由 Docker 维护。

the underpinnings in Docker Engine. So, if you ever go

looking around a system running Docker, you'll find

containerd already running there because Docker today,

the Docker Engine, pulled out a

lot of its guts, put it into containerd, and then gave that

away to the community as a nice, leaner

runtime. Then, you have another option that's popular

in the RedHat community for cri-o, C R I - O.

它实际上是 Docker 引擎的基础。
所以，如果你曾经四处寻找一个运行 Docker 的系统，
你会发现 containerd 已经在那里运行了，
因为今天的Docker引擎，拿出了它的大部分功能，
把它放到了 containerd 中，
然后把它作为一个更精简的运行时分发给社区。
然后，你有另一个选择，在红帽子社区流行的 cri-o, C R I - O.
* gut n. 内脏；肠子；剧情；胆量；海峡；勇气；直觉；肠
* give sth away to sb 赠送某人某物

That's largely maintained by RedHat and the rest of their

community.

这在很大程度上是由RedHat和他们社区的其他成员维护的。
* the rest of 其余的；剩下的

These two, different options for Docker

aren't necessarily better for you as

a user. They're mostly designed to be

minimal functionality backends

that let Kubernetes do a lot of the work.

对于Docker来说，
这两个不同的选项对用户来说并不一定更好。
它们大多被设计成最小的功能后端，
让 Kubernetes 做很多工作。
* necessarily adv.必然地;不可避免地
* minimal adj.极小的;极少的;最小的
* mostly adv.主要地;一般地;通常
* functionality n.实用;符合实际;设计目的;设计功能;(计算机或电子系统的)功能

Now, containerd does work in more distributions

right now. It does have its own command line built in

and cri-o is definitely more focused on

just being a minimum runtime free to use with Kubernetes.

现在，containerd 在更多的发行版中工作。
它内置了自己的命令行，
cri-o 显然更专注于成为一个
可以与 Kubernetes 一起使用的最小运行时。

In fact, the idea with cri-o is that you're never

interfacing with it directly.

事实上，cri-o 的想法是你永远不会直接与它联系。
* In fact事实上，其实; 准确地说;确切地说
* interface with 与…相连接
* directly adv. 直接地；立即；马上；正好地；坦率地

If you want to do anything with a container, you have to go

through Kubernetes to do it, unless you're really doing

some troubleshooting. But, a counter argument to that is

that yes, there are still plenty of times you're going to

want Docker. In fact, I will have Docker

as my engine in this course.

如果你想对容器做任何事情，
你必须通过 Kubernetes 来做，
除非你真的在做一些故障排除。
但是，一个相反的论点是，是的，
仍然有很多时候你想要 Docker 。
事实上，在这门课中，
我将使用 Docker 作为我的引擎。
* want to do想做某事; 想要做某事; 想要作某事
* go through经历，经受; 翻阅; 翻找; 整理; 通读; 彻查; 走; 例行做; 被通过; 被批准
* troubleshooting n.处理重大问题;解决难题
* plenty of 很多的

You don't have to do that. Not every distribution will have

Docker as its engine. You don't have to do that for

this course. But, I will assume that you have Docker

underneath. So, if we ever do anything with Docker, which

is probably rare, we will be doing it there.

Now, Docker does things like build the images, push

and pull the images.

Lots of other functionality and feature set over years of

Docker that's just not built into containerd or cri-o.

So, if you choose one of those other ones, realize that

it's a give or take. You're giving up functionality and

convenience, and possibly ease of troubleshooting,

especially when you're someone who knows Docker command

line well and you know how to use it in a pinch.

You're giving that up for maybe a smaller

binary, maybe a little bit of RAM or CPU back.

At this point, I'd say we're largely in an experimental

phase where most people are still choosing Docker

because they just know it.

They know how to troubleshoot it.

They know how to find the logs and all that other stuff

with the Docker engine.

What if we look out into the future?

Well, in our development environments, we yes,

will probably use Docker.

CI Pipelines, I would've said a couple of years ago that

you're probably using Docker, but we're starting to see

other tools that might make it a little easier in CI,

like Buildah from RedHat.

But, we're starting to see other tools in the community

that allow us to make it easier for building as a separate

tool than the engine itself.

But, a lot of this is experimentation and projects that

certainly have some interest, but aren't a majority of

people using it. I like to stick with what the majority

of people are using with Kubernetes because, you know,

honestly, it's hard enough without making decisions

around using tools that not everybody else is using.

So, I tend to stick with Docker.