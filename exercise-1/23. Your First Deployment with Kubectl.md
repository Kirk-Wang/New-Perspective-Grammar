Let's get ready to run some containers!

All right. This is the first time we're going to create a

real container on our own.

让我们准备运行一些容器!
好吧。这是我们第一次自己创建一个真正的容器。

Are you excited? Let's get started.

你兴奋吗？我们开始吧。

Remember, we can't create containers directly.

记住，我们不能直接创建容器。

This is an important part that I want to keep reiterating.

That we, at the lowest level,

can only create a pod.

这是我要反复强调的重要部分。
我们，在最底层，只能创造一个 pod。

In most cases, you're not even going to create a pod.

在大多数情况下，您甚至不会创建一个 pod。

You're going to create something higher than that in the

abstraction layers.

您将在抽象层中创建比这更高的东西。

We're going to explain all that in this video.

我们将在这个视频中解释所有这些。

Let's just start with a simple command.

让我们从一个简单的命令开始。

We're going to use a kubectl run, which

is as close as you can get to a docker run command.

我们将使用 kubectl run，这是最接近 docker run 命令的方式。
* as close as 和……一样近

We're going to do that to start a simple Alpine image that

is going to overwrite the default cmd.

我们将这样做，以开始一个简单的 Alpine image，这将覆盖默认的 cmd。

That's the command inside the Dockerfile, remember?

We're going to tell it, don't start a shell like

Alpine would do by default.

这是 Dockerfile 中的命令，记得吗? 
我们要告诉它，不要像 Alpine 那样默认开始一个 shell。

Just start the ping command and then ping a common, free

DNS service from Cloudflare

called 1.1.1.1. Lets type that at the command line now.

只需启动 ping 命令，
然后 ping Cloudflare 提供的一个名为 1.1.1.1 的免费公共 DNS 服务。
现在让我们在命令行中键入它。

I'm going to name it pingpong.

我要给它起名叫 pingpong。

Then, I have to put in an image.

然后，我必须放入一个 image。

That's required.

这是必需的。

Then, this is optional, but we're going to override that

default command to ping

1.1.1.1. When we hit that, we do get a warning

about a deprecated feature.

然后，这是可选的，
但我们将把默认命令覆盖到 ping 1.1.1.1。
当我们点击它时，
我们确实会得到一个关于不支持的功能的警告。

It's explaining to us something that we'll talk about

later. Essentially, it's saying the command line for

kubectl run is changing, and its behavior will be different

in the future, and we'll pay attention

that later. For now, let's just note that last line.

它向我们解释了一些我们稍后会谈到的东西。
本质上，它是在说 kubectl run 的命令行正在改变，
它的行为在未来将会不同，我们稍后会注意这一点。

It says this was created.

它说这个已经被创建了。

Great. We should be able to now do a

get all and see what we can see at the command line.

很好。我们现在应该能够在命令行中执行 get all 并查看所看到的内容。

We're going to type a kubectl get all here

and we should see a new pod.

我们要在这里输入一个 kubectl ，我们会看到一个新的 pod。

What's interesting here is that you see more than one

new object.

有趣的是，你看到的新对象不止一个。

This again, remember, is getting us all the resources

in our cluster, and we knew that this one already existed.

记住，这再次为我们提供了集群中的所有资源，我们知道这个资源已经存在了。

Like we talked earlier, this is the API connection

point for anything in our cluster if they want to talk to

the API. We have these three new ones.

如前所述，如果集群中的任何对象想要与 API 通信，
那么这里就是它们的 API 连接点。我们有这三个新的。

You'll notice, up at the top, we have a pod down

here in the middle. We have deployment.apps.

你会注意到，在顶部，我们有一个 pod 在中间。我们有 deployment.apps。

Then a replicaret.apps. Each one of these

has something with the name pingpong in it.

然后 replicaret.apps。
每一个都有一个叫 pingpong 的东西。

You'll notice that there's variations here in the

pod one and the replicaset.

你会注意到 pod one 和 replicaset 中有变化。

What's interesting is we only ran one command,

but we got three objects out of it.

有趣的是，我们只运行了一个命令，但从中获得了三个对象。

Why is that? That has to do with the layers

of abstractions inside the Kubernetes

object model. Maybe it's a little easier if we draw

this out. We don't know this yet, but

when we ran the kubectl run command,

it used something called a generator, which is a fancy way

of saying it created a specification in the background,

using a template, for us to create resource objects.

这是为什么呢?
这与 Kubernetes 对象模型中的抽象层有关。
如果我们把它画出来可能会简单一点。
我们还不知道这个，
但是当我们运行 kubectl run 命令时，
它使用了一个叫做生成器的东西，
这是一种时髦的说法，它在后台创建了一个规范，
使用一个模板，让我们创建资源对象。
* specification n. 规格；说明书；详述

What it did for us was instead of creating a pod directly,

it created something called a deployment.

它为我们做的不是直接创建一个 pod，而是创建了一个称为 deployment 的东西。

Let's just think of that as an abstraction.

我们把它看做一个抽象概念。

It's not a real thing.

这不是实际的东西。

It's an object in the etcd database.

它是 etcd 数据库中的一个对象。

But, it's not a physical thing on disk.

但它不是磁盘上的物理东西。

It's simply a configuration that's known in

Kubernetes as a spec, or a specification, or

a resource. It turns out that deployments don't create

containers directly.

We know we have to create a pod at some point, but a

deployment doesn't actually create the pod.

It creates another resource object, called the ReplicaSet.

Then, that resource finally creates

the pod.

It's interesting to note here is that all three of

these resources are really what I call abstractions.

They're layers of different functionality split

up for different purposes and to allow us to have more

flexibility in how we use Kubernetes.

This is also a source of potential confusion and complexity

because there are so many of these resources here.

But, you'll see later how it gives us a lot more

flexibility as we go.

Finally, that pod creates the container, which is

a real object running in Docker.

Inside that container, it's running the ping command.

What we have here is a set of imaginary things inside

the object model. These resources.

When we type that run command, it first created a

deployment, which is a high-level construct that

allows for certain features inside it, known as the

deployment spec.

Then a part of that deployment spec is to create a

ReplicaSet.

That ReplicaSet resource then created

a pod spec.

There's specs all the way down.

We'll see this in YAML later.

It'll make a little more sense when you see that

conceptually in data.

The last thing to note here is if you see any older

documentation talking about a replication controller,

that's technically a deprecated feature before we

had ReplicaSets, and it was known as the replication

controller. Now we know the proper way to do things is to

create the deployment, and then that will create the

ReplicaSet, which will create the pods, which creates

the container.

That's why you see those different resources all

broken out when we do the get all command.

Each one of these is based on the

thing above it. In fact, when you see the names of them,

you'll notice that the deployment is called the pingpong

like we created it.

We created it with that name, pingpong.

Then the lower level objects have an extra,

random object ID on the end of them because

they're created from the upper spec.

So technically, if we were to update this deployment later

and it needed to replace the ReplicaSet, it

might end up with a different ID, depending on what we're

changing. Same is true of the pod.

Notice that the pod has different parts of the IDs here,

and that is one indicator of many

different indicators that means these are all coming from

something else. We didn't create a pod directly.

We first created the deployment, then the ReplicaSet in the

pod. Yes, I know this seems like a lot of extra

stuff in the way of just creating a container.

Again, Kubernetes is designed for you to create

real production systems.

It's not really designed for simplistic, single

container docker runs like stuff.

We already have Docker to do that.

Kubernetes wasn't there to solve that problem because it

had already been solved. It's trying to solve more complex

problems. Which is what we'll see later as deployments

will allow us to create rolling updates, without downtime,

and a whole lot of other features.

