All right. Let's jump back to the run command again for a

few minutes. It turns out the run command does

this thing in the background that's a little bit of

automation. It's essentially using templates to create

these specifications.

好吧。让我们再回到 run 命令几分钟。
run 命令在后台做这个，有点自动化。
它本质上是使用模板来创建这些规范。

Based on how you type the run command

kubectl will send different information

to the cluster for what it needs to create to

get the job done. In the case of our first command, it

figured, OK, you need a deployment.

根据您键入 run 命令的方式，
kubectl 将向集群发送不同的信息，
以了解它需要创建什么来完成任务。
在我们的第一个命令中，它认为，
好吧，您需要一个 deployment。

That is the most popular way to run

a container in Kubernetes is with a deployment.

在 Kubernetes 中，最流行的运行容器的方法是 deployment。

It allows you to scale up replicas and scale down.

它允许您放大 replicas 和缩小规模。

It allows a lot of other features like rolling updates.

它允许很多其他功能，如滚动更新。

So, it is your standard way to do things,

especially in production.

所以，这是你做事的标准方式，尤其是在生产中。
* especially adv.尤其;特别;格外;专门;特地;十分;非常

Deployments are it, right.

Deployments 就是这样，对吧。

That's the key one. But, there's lots of other types of

ways we might want to run containers.

这才是关键。但是，我们可能还有很多其他类型的方法来运行容器。

kubectl run is a

simple enough command that allows us flexibility to change

even just the littlest thing inside that command, and it

will change what it actually creates.

kubectl run 是一个非常简单的命令，
它允许我们灵活地更改该命令中最细微的内容，
并且它将更改它实际创建的内容。

Here's an example where we could run a

kubectl run with a --restart

on failure, meaning that it will only restart

if it crashes, and it won't restart if it

closes in a healthy state.

这里有一个例子，
我们可以运行一个 kubectl run 
带有一个 --restart 在 failure 上，
这意味着它只会在崩溃时重新启动，
而在正常关闭时不会重新启动。

Or, we could say restart never with

that --restart.

我们可以说 restart，从来不以 --restart。

Those two would create different types of

resources.

这两者将创造不同类型的资源。

It may sound a little complicated, but it is meant

to be simple enough that you don't have to know all the

different resource types to just start something.

这听起来可能有点复杂，
但它意味着足够简单，
您不必了解所有不同的资源类型
就可以开始做一些事情。
* complicated adj.复杂的;难懂的
* meant to be 命中注定; 命中注定的; 意味

That first one, it will create a job

because technically a job is a one-time thing

you need to do, like a batch job.

第一个，它将创建一个 job，因为从技术上讲，
job 是您需要一次性完成的事情，
就像批处理 job 一样。
* one-time 原先的; 从前的; 一度的; 一次性的; 一切全包的

That would be something that you don't need to restart

if it does a healthy exit.

这将是一个你不需要重新启动，如果它做了一个健康的退出。

Make a little sense? Then on the --restart never, that's

going to just create a bare pod.

明白了吗? 然在 --restart 上决不，这只会创建一个 bare(裸) pod。

It's not going to create a full deployment because we're

saying, I don't care what you do if it crashes,

if it stops healthy state, just whatever

happens. If it stops, leave it alone.

它不会创建一个完整的部署，
因为我们说，
我不关心你做什么，
如果它崩溃，
如果它停止健康状态，
不管发生什么。
如果它停止了，不要去管它。

That's often what you need to do in a real world production

case. You maybe need to just create a simple pod for

troubleshooting and some other diagnostic thing.

这通常是在实际生产环境中需要做的事情。
您可能需要创建一个用于故障排除和其他诊断的简单 pod。
* troubleshooting 故障排除，处理重大问题;解决难题
* diagnostic adj.诊断的;判断的

Because pods don't have those higher levels of abstraction

above it, if you're just creating a single pod, you

probably don't use it very often in a real world setup.

因为 pod 并没有更高层次的抽象，
如果您只是创建一个单独的 pod，
那么您可能不会经常在实际环境中使用它。

The default is still deployment.

默认仍然是 deployment。

I talked about generators earlier, but generators,

think of them as templates.

我之前谈到了 generators，但是 generators，可以把它们看作模板。

They...for each type of run command will

generate the specification based on templates

that come out-of-the-box.

他们……对于每种类型的 run 命令，
都将基于开箱即用的模板生成规范。

If we use the --schedule with the run

command, we can create a different type of job

known as a cron job.

Once you get deployments down in your clusters

for real world production setups, and you're deploying a

bunch of deployments that have ReplicaSets, that have pods,

one of the more popular things you need next

in terms of running with your apps, are cron jobs, or

something like maintenance jobs, right.

This isn't technically running a real cron

job on a server.

It's not running the cron agent, per se.

It's doing a distributed cron-like

thing in Kubernetes where based on

the values you set, it will restart

and run a job, which is in a pod.

It will restart and run that container on a regular basis.

Maybe you need to run something every day to clean up

images. Maybe you need to do something every day for

getting rid of caching, or refreshing your caching once an

hour, or something like that.

That's what the cron job is meant for.

It's not like deployments where it's meant to always

run. Deployments are designed to always run and stay

running. If they fail, it recreates them, right.

Cron jobs are a little bit different.

Let's create one now.

At the command line, this is a little bit longer of a

command, but it's still the same format as before.

We're just adding --schedule and --restart.

We're saying kubectl run --schedule

of the cron job.

If you're familiar with cron jobs on

standard Unix systems, this is in the same format.

If you look at the previous slide, it breaks down

which of these values is for minutes, hours, days, stuff

like that. In this case, what we're saying is run every

three minutes.

The --restart on failure

is what we want. We only want it to restart in

case it doesn't finish. If it finishes in a bad state, with

an error code, we'd want to rerun that cron job.

But, if it starts and then stops in a healthy state,

we don't want it to recreate until the scheduled time,

every three minutes. All right.

That's sort of a normal thing for a cron-like batch job.

With the Alpine image, which is what we ran before,

we're going to just run a sleep.

A sleep command means do nothing, but this is just an

example, right. We'll get into concrete applications

later in the course. Now, we're just exploring the basics

of the UI.

We're going to sleep for 10 seconds. It's going to give

us another one of these deprecated warnings.

We'll talk about that in a few minutes.

But until then, let's do a kubectl get,

you guessed it, cronjobs. The

name of this resource.

You can see here it gives us different information.

It actually shows us the schedule, the suspend, the last

time it ran.

That's some cool stuff just for that resource type.

You'll see here that each resource type we use, we can

use the get command to get it.

We can use the delete command to delete it.

We'll see different information based on that resource's

API really.

But, what's that doing?

Well, that cron job is really just creating a container.

It's putting that container in a pod by creating a pod

spec, assigning that to a node and then asking that node

to create that work. In this case, it's just doing the

sleep.

