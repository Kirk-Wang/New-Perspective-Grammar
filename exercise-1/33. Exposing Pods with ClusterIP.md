All right. Let's create a deployment with something that we

can use to expose.

好吧。让我们创建一个 deployment，使用一些可以公开的东西。

Now, we can't just use ping because that's not listening

on any ports, and it's not going to return anything if we

try to cURL it. Let's launch a simple little

utility called httpenv.

现在，我们不能只使用 ping 
因为它不会监听任何端口，
如果我们试图 cURL 它，
它不会返回任何东西。
让我们启动一个简单的小工具，
叫做 httpenv。

Created by my friend Jerome.

是我朋友 Jerome 创造的。

This is really just a 20 or 30 line Go program

that starts a web server listening on port

8888. Then, all it will do when you cURL

it is return the environment variables that

Kubernetes gave the application when it launched it.

这实际上只是一个20或30行的 Go 程序，
它启动一个 web 服务器，监听端口 8888。
然后，当您使用 cURL 时，
它所做的就是返回 Kubernetes 在应用程序
启动时给它的环境变量。

One of the benefits here is that when it returns that data,

it'll return the hostname, which is also the container

name in the pod, which is nice because it

allows us to see different endpoints and where we're

actually connecting to this thing. So, it's pretty neat for

a simple little utility in a distributed system like this.

Here, we could just do a kubectl run like we're used to,

but I want to get you used to these other commands like

create. I really like create.

这里的一个好处是，当它返回数据时，
它会返回主机名，这也是 pod 中的容器名，
这很好，因为它允许我们看到不同的端点
以及我们实际连接到这个东西的地方。
所以，对于这样一个分布式系统中的一个简单的小工具来说，
这是非常棒的。这里，
我们可以像往常一样运行 kubectl，
但我想让你们习惯这些其他命令，
比如 create。我真的很喜欢 create。
* that's pretty neat 顶呱呱的

It allows me to be very specific about what

I'm creating instead of the run, which is evolving

and changing over time.

它允许我非常具体地描述我正在创建什么，
而不是 run，
它是随着时间的推移而发展和变化的。
* over time 随着时间的过去；超时
* evolving v.(使)逐渐形成，逐步发展，逐渐演变;进化;进化形成
* changing v.改变;变化;使不同;(使)变换，改换，变成

Who knows what it will be doing a year or two from now.

谁知道一两年后会发生什么。

Let's stick with the create command instead.

让我们改为使用 create 命令。
* stick with 坚持做; 紧跟; 紧随; 和…呆在一起
* instead代替; 顶替; 反而; 却

I'm going to have to windows open so we can watch this

happen. In one window, I'm going to use a kubectl get

pods with a -w.

我得把打开一个窗口，
这样我们才能看到这一切的发生。
在一个窗口中，
我将使用 kubectl get pods 带有一个 -w。

It's a new option you haven't seen yet, but that allows us

to watch things as they're created.

这是一个你还没见过的新选项，
但它允许我们在事物被创造出来的时候观察它们。

It's a pretty neat option on the get command.

这是 get 命令的一个非常好的选项。

It'll sit here and wait for stuff to happen.

它会坐在这里，等着事情发生。

Then you'll see it, almost like watching logs,

it'll just put the different lines of the different states

that things are in as they happen.

然后你会看到它，就像看日志一样，
它会把事情发生时所处的不同状态的不同行放在一起。

Over here on the right, I'm going to do a kubectl create

deployment.

在右边这里，我要做一个 kubectl create deployment。

We're going to call this httpenv.

我们称它为 httpenv。

We're going to use my image bretfisher/httpenv.

我们将使用我的 image，bretfisher/httpenv。

When we do that, it's going to create one pod.

当我们这样做的时候，它会产生一个 pod。

It's a little confusing on the left if you're not used to

that, is it looks like it's creating lots of things.

如果您不习惯这种用法，那么左侧的内容可能会让人感到困惑，
因为它似乎正在创建很多东西。

This is not the same as other options

you've seen for watching real-time commands happen.

这与您所见过的用于监视实时命令发生的其他选项不同。
* same as 等同于；与…一致

This one is just giving us any time there's

a state change, or any information that changes about a

pod, it just lists another line.

这只是在状态变化或任何有关 Pod 的信息更改时给我们的信息，
它仅列出了另一行。

It's not going to squash them all together and to show just

one line updating itself.

Think of it like a log.

Now we know the latest state is it's

running, OK.

If we did control c here, and

then we did get pods without the -w,

we would see that, yep, we just have this one pod here for

httpenv. If we do get all, of course we're going

to see the deployment and the ReplicaSet that

match this pod.

We've seen that. Nothing new.

All right. Now, let's go back on the left.

We're going to do the -w again on the pods command

so that we can watch it. Then we're going to scale this up,

scale deployment httpenv. We're giving

it the deployment name --replicas 10.

You'll see all sorts of stuff happen on the left.

Now that that's happened, I'm going to use an expose

command to create this service for

those pods. kubectl expose

deployment httpenv.

I'm going to tell it the port that it's running on

8888.

That's which port my pods are listening

on. What's interesting here is that we are telling

it to expose a deployment, but it's not really routing

traffic to a deployment.

A deployment is just a concept.

It's an abstraction.

It's the pods that need to receive traffic.

So, really what's happening is in IP tables, on

our nodes, we're creating rules via the kube-proxy

agent. It's going to direct traffic to

the pods in a round robin fashion, by default,

on Port 8888.

It's using the deployment as a selector for deciding

which pods need to be inside this service.

That's why we're using the deployment here.

All right. This doesn't change our pods.

You'll notice on the left that the pods don't have to

update because we're really creating just an additional

resource type that is now going to be able

to route traffic. If we do a kubectl get service,

you'll see that we now have two.

The original one, which is the cluster IP of

the cluster itself for Kubernetes.

Then this new one for our deployment,

httpenv. You'll notice that the service is also called

httpenv. Here's a tip about naming.

Inside of any namespace, and remember, we're in the default

namespace right now.

In a namespace, you can have the same name

for different resource types, but you can't have

a name collision of the combination

of the resource type and the name of the resource.

So, I couldn't have two services called httpenv,

but I can have a deployment called that and a service

called that. That makes sense.

All right.